# Add this code to your app. It uses a TTF font (DejaVu Sans) for full Unicode support.
# Place DejaVuSans.ttf at: ./fonts/DejaVuSans.ttf (create fonts/ folder in repo).

import io
import textwrap
from fpdf import FPDF

# Register and use a TrueType font to get full unicode support.
# Make sure file exists at fonts/DejaVuSans.ttf
FONT_PATH = os.path.join("fonts", "DejaVuSans.ttf")
if not os.path.exists(FONT_PATH):
    raise FileNotFoundError(f"Font file not found: {FONT_PATH}. Put DejaVuSans.ttf at fonts/")

def _wrap_and_sanitize(text_obj: object, wrap_width: int = 90) -> str:
    """Wrap text to `wrap_width`. Keep unicode intact (we will use a unicode-capable TTF)."""
    if text_obj is None:
        return ""
    s = str(text_obj)
    # Normalize common curly quotes/dashes to simple equivalents for readability
    s = s.replace("—", "-").replace("–", "-").replace("“", '"').replace("”", '"').replace("’", "'")
    # Break extremely long tokens to avoid layout issues
    tokens = []
    max_token = 200
    for token in s.split(" "):
        if len(token) > max_token:
            chunks = [token[i:i+100] for i in range(0, len(token), 100)]
            tokens.append(" ".join(chunks))
        else:
            tokens.append(token)
    safe = " ".join(tokens)
    wrapped = "\n".join(textwrap.fill(line, width=wrap_width) for line in safe.splitlines())
    return wrapped

def build_pdf_bytes_with_ttf(biz_df, camp_df, spikes_df, low_roas_df):
    """
    Build PDF bytes using DejaVuSans TTF for full unicode support.
    Returns bytes ready for st.download_button.
    """
    pdf = FPDF()
    # register TTF (TrueType) font for unicode; family name "DejaVu"
    pdf.add_page()
    pdf.add_font(family="DejaVu", style="", fname=FONT_PATH, uni=True)
    pdf.set_auto_page_break(auto=True, margin=12)

    # compute usable width
    usable_w = pdf.w - pdf.l_margin - pdf.r_margin

    # Title
    pdf.set_font("DejaVu", size=14)
    pdf.multi_cell(usable_w, 8, _wrap_and_sanitize("Marketing Intelligence - Summary", wrap_width=100))

    pdf.ln(2)
    pdf.set_font("DejaVu", size=10)
    pdf.multi_cell(usable_w, 6, _wrap_and_sanitize(f"Date range: {biz_df['date'].min()} to {biz_df['date'].max()}"))
    pdf.multi_cell(usable_w, 6, _wrap_and_sanitize(f"Total Revenue: ${biz_df['total_revenue'].sum():,.0f}"))
    pdf.multi_cell(usable_w, 6, _wrap_and_sanitize(f"Marketing Spend: ${biz_df['spend'].sum():,.0f}"))
    roas_val_pdf = biz_df['attributed_revenue'].sum() / (biz_df['spend'].sum() or np.nan)
    pdf.multi_cell(usable_w, 6, _wrap_and_sanitize(f"ROAS: {roas_val_pdf:.2f}" if not np.isnan(roas_val_pdf) else "ROAS: N/A"))

    pdf.ln(4)
    pdf.set_font("DejaVu", size=11)
    pdf.multi_cell(usable_w, 6, _wrap_and_sanitize("Top campaigns (by spend)"))
    pdf.set_font("DejaVu", size=9)
    if camp_df is not None and not camp_df.empty:
        top = camp_df.sort_values("spend", ascending=False).head(8)
        for _, row in top.iterrows():
            line = f"- {row.get('campaign','')[:200]} | {row.get('channel','')} | spend: ${row.get('spend',0):,.0f} | ROAS: {row.get('roas',np.nan):.2f}"
            pdf.multi_cell(usable_w, 5, _wrap_and_sanitize(line, wrap_width=100))
    else:
        pdf.multi_cell(usable_w, 5, _wrap_and_sanitize("No campaign data available."))

    pdf.ln(6)
    pdf.set_font("DejaVu", size=11)
    pdf.multi_cell(usable_w, 6, _wrap_and_sanitize("Anomalies Detected"))
    pdf.set_font("DejaVu", size=9)
    if not spikes_df.empty:
        pdf.multi_cell(usable_w, 5, _wrap_and_sanitize("Spend spikes:"))
        for _, r in spikes_df.head(8).iterrows():
            pdf.multi_cell(usable_w, 5, _wrap_and_sanitize(f"- {r['date']} | {r['channel']} | spend: ${r['spend']:,.0f}"))
    else:
        pdf.multi_cell(usable_w, 5, _wrap_and_sanitize("No spend spikes detected."))

    if not low_roas_df.empty:
        pdf.ln(2)
        pdf.multi_cell(usable_w, 5, _wrap_and_sanitize("Low ROAS days:"))
        for _, r in low_roas_df.head(8).iterrows():
            pdf.multi_cell(usable_w, 5, _wrap_and_sanitize(f"- {r['date']} | spend: ${r['spend']:,.0f} | roas: {r['roas']:.2f}"))
    else:
        pdf.multi_cell(usable_w, 5, _wrap_and_sanitize("No low-ROAS days detected."))

    # output bytes (binary)
    pdf_bytes = pdf.output(dest="S").encode("latin-1", "replace")
    return io.BytesIO(pdf_bytes).getvalue()

# Usage in Streamlit:
# pdf_data = build_pdf_bytes_with_ttf(filtered_business_df, campaign_pdf_df, spend_spikes_df, low_roas_df)
# st.sidebar.download_button("Download PDF (Unicode)", data=pdf_data, file_name="marketing_summary_unicode.pdf", mime="application/pdf")
